{
  "content": "QQuuaannttuumm CCoommppuutteerrss aanndd QQuuaannttuumm CCoommppuutteerr LLaanngguuaaggeess:: QQuuaannttuumm AAsssseemmbbllyy LLaanngguuaaggee aanndd QQuuaannttuumm CC** By Stephen Blaha** * Excerpted from the book Cosmos and Consciousness by Stephen Blaha (1stBooks Library, Bloomington, IN, 2000) available from amazon.com and bn.com. ** Associate of the Harvard Un iversity Physics Department.\niiABSTRACT We show a representation of Quantu m Computers defines Quantum Turing Machines with associated Quantum Gr ammars. We then create examples of Quantum Grammars. Lastly we develop an algebraic approach to high level Quantum Languages using Quantum Assembly language and Quantum Clanguage as examples.\niiiCOPYRIGHT NOTICES AND ACKNOWLEDGMENTS Copyright © 1998-2002 Stephen Blaha. All rights reserved. This material from the book Cosmos and Consciousness is protected under copyright laws and international copyright conventions. No part of this material may be reproduced by any means in any form without express prior written permission. Excerpts from this material can be made for the purpose of review or comment in journa ls and magazines as long as appropriate credits are given. Quantum Probabilistic Grammar, Probabilis tic Grammar, Probabilistic Computer Grammar, Quantum Grammar, Continuum Quantum Computer, Polycephalic Quantum Computer, Quan tum Assembly Language, Bit-Level Quantum Computer Language, Quantum C Language are trademarks or registered tr ademarks of Janus Associates Inc. Scientific publications may use these trademarks if they include a statement attributing ownership of the mark s to Janus Associates Inc. and attach a ™ superscript to the mark in the text of the document. The statement attributing ownership should say “____ is a trademark of Janus Associates Inc. ”\nCONTENTS PROBABILISTIC COMPUTER GRAMMARS 1 PROBABILISTIC COMPUTER GRAMMARS 1 QUANTUM PROBABILISTIC GRAMMAR 2 QUANTUM TURING MACHINES 3 WHAT ARE TURING MACHINES ?3 FEATURES OF NORMAL TURING MACHINES 3 QUANTUM PROBABILISTIC GRAMMARS 4 THE STANDARD MODEL QUANTUM COMPUTER 6 THE STANDARD MODEL QUANTUM TURING MACHINE 6 QUANTUM COMPUTER PROCESSOR OPERATIONS AND QUANTUM COMPUTER LANGUAGES 10 INTRODUCTION 10 COMPUTER MACHINE AND ASSEMBLY LANGUAGES 10 MEMORY 10 ALGEBRAIC REPRESENTATION OF ASSEMBLY LANGUAGES 11 BASIC OPERATORS OF THE ALGEBRAIC REPRESENTATION 13 A SIMPLE ASSEMBLY LANGUAGE PROGRAM 17 PROGRAMS AND PROGRAM LOGIC 17 QUANTUM ASSEMBLY LANGUAGE ™ P ROGRAMS 20 BIT-LEVEL QUANTUM COMPUTER LANGUAGE 23 BASIC OPERATORS OF THE BIT-LEVEL QUANTUM LANGUAGE 24 QUANTUM HIGH LEVEL COMPUTER LANGUAGE PROGRAMS 25 QUANTUM C L ANGUAGE ™2 7\n111 PPrroobbaabbiilliissttiicc CCoommppuutteerr GGrraammmmaarrss Probabilistic Computer Grammars The preceding chapter described the production rules for a deterministic grammar. The left si de of each production rule has one, and only one, possible transition. Non-deterministic grammars allow tw o or more grammar rules to have the same left side and differe nt right sides. For example, A → y A → x could both appear in a non-deterministic grammar. Non-deterministic grammars ar e naturally associated with probabilities. The probabilities can be classical probabilities or quantum probabilities. An exampl e of a simple non-deterministic grammar is:The head symbol is the letter S. Th e terminal symbols are the letters x and y. The production rules are: S → xy Rule I x → xx Rule II Relative Probability = .75 x → xy Rule III Relative Probability = .25 y → yy Rule IV The probability of generating th e string xxy vs. the probability of generating the string xyy from the string xy is xy → xxy relative probability = .75 vs. xy → xyy relative probability = .25 The string xxy is three times more lik ely to be produced than the string xyy. For each starting string one can obta in the relative probabilities that various possible output strings will be produced. A more practical example of a Probabilistic Grammar can be abstracted from flipping coins – heads or tails occur with equal probability – 50-50. From this obs ervation we can create a little Probabilistic Grammar for the case of flipping two coins. Let us let h represent heads and t re present tails. Then let us choose the grammar: S → hh S → tt S → ht S → th h → t probability = .5 (50%) h → h probability = .5 (50%) t → h probability = .5 (50%)\n2t → t probability = .5 (50%) The last four rules above embody th e statement that flipping a coin yields heads or tails with e qual probability (50% or .5). Now let us consider starting with two heads hh. The possible outcomes and their probabilities are: hh → hh probability = .5 * .5 = .25 hh → th probability = .5 * .5 = .25 hh → ht probability = .5 * .5 = .25 hh → tt probability = .5 * .5 = .25 If we don’t care about the order of the output heads and tails then the probability of two heads hh → ht or th is .25 + .25 = .5. This simple example shows th e basic thought process of a non- deterministic grammar with associated probabilities. The combination of a non-deterministic grammar and an associated set of probabilities for tran sitions can be called a Probabilistic Grammar . We will see that the grammar produc tion rules for the Standard Model must be viewed as constituting a Probabilistic Grammar™ with one difference. The “square roots” of pr obabilities – probability amplitudes are specified for the transitions in the grammar. Probability amplitudes are required by the Standard Model because it is a quantum theory. Therefore we will call the gram mar of the Standard Model a Quantum Probabilistic Grammar™ . Quantum Probabilistic Grammar Physics examples are presented he re in the book. There are additional chapters also omitted.\n322 QQuuaannttuumm TTuurriinngg MMaacchhiinneess What are Turing Machines? The linguistic view of the Stan dard Model leads to a number of questions. One important question is the nature of the Turing machine that accepts this language. A Turing machine is a generalizedtheoretical computer that is ofte n used to analyze computational questions in computer science. A personal computer can be viewed as a special purpose Turing machine. A personal computer has memory in the form of RAM and hard disks. A personal computer ha s built-in programs that tell it what to do when data is input into the computer. Similarly a Turing machine also has memory and instructions within it telling it how to handle input and how to produce output from a given input.When we type input on a computer keyboard or have input come from another source such as the Internet or a data file, the input has to be in a form that the computer can handle. Similarly, the input for a Turingmachine must have a specific form for the Turing machine to accept it, process it and then produce output. In the case of a Turing machine we say the input must be presented in a language that the Turing machine “accepts”. In this context the word “accepts” means a format that theTuring machine can recognize and anal yze so that it can process the data to produce output. The language of the Standard Model is a type 0 computer language. A type 0 language requires a Turing machine to handle its productions. Because particle transitions are quant um and because the left side of a production rule can have several possi ble right sides (For example, a photon can transition to an electr on-positron pair, a quark-antiquark pair and so on.) the Turing machin e for the Standard Model language must be a non-deterministic Quantum Turing Machine. Features of Normal Turing Machines Before examining a Quantum Turing Machine for the Standard Model we will look at the features of “normal” Turing machines. A normal Turing machine consists of a fin itely describable black box (its features are describable in a fi nite number of statements) and an infinite tape. The tape plays the ro le of computer memory. The tape is divided into squares. Each square c ontains a symbol or character. The character can be the “blank” charac ter or a symbol. A tape contains blank characters followed by a finite string of input symbols followed by blank characters. The black box consists of a control part and a tape head. The control part has a finite set of rules built into it (the “program”) and a finite memory that it uses as a scratch pad normally. The tape head can read symbols from the tape one at a time and can move the tape to the left,right, or not move it, based on inst ructions from the control part. The tape head tells the control the symbols it is scanning from the tape and the control decides what action to have the tape perform based on the scanned symbols and information (the program and data) stored inthe control’s memory.\n4 Black Box … b i n p u t b … Tape Figure. Schematic diagram of a Turing machine.A set of input symbols is placed on the tape and the rules (program) in the control part are applied to produce an output set of symbols. This process is analogous to elementary particle processe s: an input set of particles interacts through various forces of nature and produces an output set of particles. The differe nce is that elementary particle processes are quantum probabilistic in nature. The laws of Physics (which appear to be fi nitely describable since they can be specified by the Standard Model lagrangian except for gravity) play the role of the finite set of rules. Quantum Probabilistic Grammars The major difference between Turi ng machine outputs and the outputs in particle physics are that outpu t states in particle physics are quantum probabilistic. A given set of input symbols (particles) can produce a variety of output states with different probabilitiescalculable in the Standard Mode l. We need a Quantum Turing Machine to handle this more complex situation. Quantum (and non-quantum) Turing Mach ines can be pictured in a convenient way by viewing the contro l part as containing a tape on which the rules are inscribed, the cu rrent state of the Turing machine is specified, and the current symbol being scanned by the tape head is stored. The grammar rules of a Quantum Turing Machine are quantum probabilistic. In the simplest case eac h grammar rule has an associated number that we will call its relative probability amplitude. We will callthis type of Quantum Probabilistic Grammar™ a factorable Quantum Probabilistic Grammar . The calculation of th e probability for a transition from a specifi ed input string to a specified output string is based on the following rules: 1. The relative probability amplit ude for an input string to be transformed to a specified output string is the sum of relative probability amplitudes for each possible sequence of transitionsthat leads from the input string to the output string. 2. The relative probability amplitude for a sequence of grammar rule transitions is the product of the relativeprobability amplitudes of each transition. 3. The relative probability for an input string to be transformed to an output string is the absolu te value squared of the relative probability amplitude for the input string to be transformed to the output string. 4. The absolute probability for an input string to be transformed to a specified output string is the relative probability for the input string to be transformed to the specified output string divide d by the sum of the relative probabilities for the input string to be transformed to all possible output strings using the grammar rules. This rule guarantees the sum of the probabilities sums to one. Control Part Finite set of Rules Finite Memory Ta pe Head\n5A Physics example is presented here in the book.\n633 TThhee SSttaannddaarrdd MMooddeell QQuuaannttuumm CCoommppuutteerr The Standard Model Quantum Turing Machine The Quantum Turing Machine that co rresponds to the Standard Model has a number of exciting features th at distinguish it from conventional Turing Machines. First it accepts a language that has a finitely describable entangled Quantum Grammar™. Although the Sta ndard Model has an entangled Quantum Grammar the grammar rules ar e finitely describable. Finitely describable means that the rules can be specified by a finite set of symbols. The rules generated from the interactions of the Standard Model are finite in number and each rule consists of a finite number ofsymbols. Thus the rules generated from the Standard Model arefinitely describable. A Quantum Turing Machine can be visualized as consisting of a control element and two tapes that pl ay the role of computer memory. The control has a tape head that re ads and writes symbols to the two tapes.Tape I contains the specification of the grammar rules expressed as a finite string of symbols, the cu rrent state of the Quantum Turing Machine, and other data. Tape II contains the input string. After applying the grammar rules in a quantum probabilistic way an outputstate is generated. The output state is placed on Tape II in the simplest Quantum Turing Machine implementation. Tape I current … aaaaa Finite String of Rules Current State symbol scanned Tape II … bbbbbb[input state]bbbbb … Figure. Quantum Turing Machine. Ta pe I plays the role of computer memory. Tape II is memory for input and output. The behavior of a Quantum Turing Machine can be viewed as:1. The Turing machine begins in the input state specif ied on tape II. An input string is placed on tape II. The other memory locations on tape II are filled with blank charact ers. In our case this string is a list of symbols for an input set of elementary particles that are about to interact. The Turing mach ine we are considering accepts any state consisting of a finite num ber of elementary particles. The Control Tape Head\n7connection between Turing machines and computer languages is brought out at this stage. A m achine “accepts” a language if it can take any sentence (set of particle s in our case) of the language, and perform a computation producing out put (a set of output particles in our case). A Turing machine that accepts a language is an embodiment of the grammar of the language. 2. The Quantum Turing Machine appl ies the grammar rules to the input set of states in all possibl e ways to produce an output state that is a quantum superposition of states. Each possible output state has a certain probability of being produced. 3. The probability for producing a specified output state from a specified input state can be calculated as we illustrated in a simple example earlier using the relative probabilities associated with the Quantum Grammar™ rules of the modified &3 theory. 4. The set of possible states of a Quantum Turing Machine1 is infinite unlike non-Quantum Turing Machin es that only have a finite number of possible states. The Standard Model Quantum Turing Machine has some distinctive features: 1. Since the order of the particles in the input state string is not physically important we will c onsider the input string to be actually all permutations of the or der of the partic les in the input. 2. Since the Turing machine is quantum the rules are probabilistic in nature: a given set of input particles will in general produce many possible output particle states. Each output state will have a certain 1 D. Deutsch, Proceedings of the Royal Society of London, A 400 97 (1985) describes (universal) Quantum Computers and points out they can simulate continuous physical systems because they have a continuum (infinite number) of possible states. As page 107 points ou t “a quantum computer has an infinite- dimensional state space”. Quantum Computers are equivalent to Quantum Turing Machines as we will see.probability of being produced that can be calculated using the Standard Model. 3. The Quantum Grammar™ rules of the Standard Model Quantum Turing Machine have internal symmetries that result in symmetriesin the input and output states. 4. Since the momenta and spins of th e input and output particles are physically very important the Standard Model Quantum Turing Machine must take account of th ese properties in the input and output states as well as intern ally when calculating transition probabilities. So we must picture the input particle state on ta pe II as containing not only the particle symbol but also momenta and spin data. To get an idea of how a Quantum Turing Machine would take an input set of particles and pr oduce a set of output part icles we will consider the case of two electrons colliding with such energy that an electron- positron pair is created: ee → eepe where e represents an electron and p represents a positron (the electron’s antiparticle). One of the corresponding Feynman-like diagrams is:\n8 1 2 3 4 5 e e γ e p γ e e where γ represents a photon. The input string can change according to the grammar rules in the following way: ee → eγe → eγγe → eepγe → eepe Since the Quantum Turing Machine is probabilistic there are many – in fact an infinite number – of ways in which the transition ee → eepe can take place – each with its own probability of happening. The sample sequence of transitions s hown above is only one of these possible ways. The total probability of this transition is the square ofthe sum of the probability amplit udes for all possible ways according to quantum mechanics. Nature requ ires us to take account of all possible ways of transitioning from th e input state of particles to the output state of particles. The total probability of the output state beingproduced is a sum of the contributi ons of all the possible alternate ways of reaching that output state. In addition, electron-electron scat tering can produce many other output states depending on the initial energy of the electrons. Each output state has its own probability of occurring. Some examples are: ee → eqqe ee → eepepe ee → eµµe ee → eµµepe where q represents a quark, µ represents the muon antiparticle and q represents an antiquark. The Quantum Turing Machine representation does raise several interesting prospects fo r the theory of elemen tary particles embodied in the Standard Model. Firs t, the Quantum Turing Machine representation raises the possibil ity that some of the powerful techniques and general results of the theory of computation can be brought over to physics and perhap s provide guidance on the next stage after the Standard Model. Secondly, and perhaps more importan tly, the separati on of the input and output states (they are on ta pe II) from the intermediate calculational states of the Turing machine (that are on tape I) issuggestive of a somewhat different approach to the fundamentals of particle interactions: The spa ce-time of the incoming and outgoing particles may be different from the “space-time” describing the interactions and internal structure of the interacting particles. This view is based on thinking of tapes I and II as representing separate space-times.\n9A precursor of this point of view appears in Quantum Field Theory. In Quantum Field Theory the interact ion of particles is viewed as consisting of three phases: an init ial state where the particles are widely separated and distinct, an in teraction region wh ere the particles “collide” and interact perhaps creati ng new particles, and a final state where the outgoing particle s are widely separated. Figure. Two particles collide and generate a three particle outgoing state in Quantum Field Theory. In conventional Quantum Field Theory the space-time in the interacting region is conventionally assumed to be the same as the space-time of the incoming and outgoing states. Nevertheless Quantum Field Theory distinguishes the interaction region from the region of the incoming and outgoing particles. The SuperString approach to the theory of elementary particles introduces a separate space-time to de scribe the elementary particles. Elementary particles are viewed as strings vibrating in this space-time. Can one view the SuperString space -time as tape I and the external behavior of the elementary partic les taking place in normal space-time as tape II? Perhaps the Quantum Tu ring Machine representation of the Standard Model is the key to th e next level of our understanding of elementary particles and Nature.\n1044 QQuuaannttuumm CCoommppuutteerr PPrroocceessssoorr OOppeerraattiioonnss aanndd QQuuaannttuumm CCoommppuutteerr LLaanngguuaaggeess Introduction A natural question that arises when one considers Quantum Computers is the role of the Quantum Comput er processor and the operations it supports. A further question of some interest is whether a quantum machine language exists and what its nature might be. Lastly the question of higher level languages is also relevant. Can we develop a Quantum Assembly Language™? What is the nature of High Level Quantum Languages™? Are there, for example, equivalents to the C or C++ languages?Computer Machine and Assembly Languages The traditional (non-quantum) computer can be viewed simply as a main memory, an accumulator or register (modern computers havemany registers), and a central pro cessing unit (CPU) that executes a program (instructions) step by st ep. It can be visualized as: Memory Memory Address Word 0 Word 1 Word 2 …3 Figure. Simplified model of a normal computer. A set of data and a program (or set of instructions) is stored in memory and the CPU executes the program step by step using the data to produce an output set of data. The basic instructions of asse mbly language and machine language move data values between memory and the register (or registers), manipulate the data value in the re gister and provide basic arithmetic and logical operations2: LOAD M – load the value at memory location M into the register STORE M – store the value in th e register at memory location M SHIFT k – shift the value in the register by k bits 2 See for example Kurt Ma ly and Allen R. Hanson, Fundamentals of the Computing Sciences (Prentice-Hall, Inc., Englewood Cliffs, NJ, 1978) Chap. 8.RegisterCPU\n11The following arithmetic instructions modify the value in the register. The AND, OR and NOT instructions perform bit-wise and, or and not operations. ADD M – add the value at memory location M to the value in the register SUBTRACT M – subtract the value at memory location M from the value in the register MULTIPLY M – multiply the va lue in the register by the value at memory location M DIVIDE M – divide the value in the register by the value at memory location M AND M – change the value in the register by “anding” it with the value at memory location M OR M – change the value in the register by “oring” it with the value at memory location M NOT – change the value in the register by “not-ing” it The following instructions implement input and output of data values. INPUT M – input a value storing it at memory location MOUTPUT M – output the value at memory location M A computer has another register called the Program Counter. The value in the program counter is the memory location of the next instruction to execute. The fo llowing instructions support non- sequential flow of control in a program. A program can “leap” from one instruction in a program to another instruction many steps away and resume normal sequential execution of instructions.TRA M – set the value of the program counter to the value at memory location M TZR M – set the value of the program counter to the value at memory location M if the value inthe register is zero. HALT – stop execution of the program The above set of instructions form an extremely simple assembly language. They also are in a one-t o-one correspondence with machine instructions (machine language). Most assembly and machinelanguages have a much more extensive set of instructions. Algebraic Representati on of Assembly Languages The normal view of assembly langua ge is that it has a word or instruction oriented format. Some assembly language programmerswould even say that assembly la nguage is somewhat English-like in part. Computer languages in general have tended to become more English- like in recent years in an at tempt to make them easier for programmers. Some view a form of highly structured English to be a goal for computer programming languages. In this section we follow the opposit e course and show that computer languages can be reduced to an alge braic representation. By algebraic we mean that the computer language can be represented with operator expressions using operator s that have an algebra similar to that of the raising and lowering operators seen earlier. We will develop thealgebraic representation for the case of the simple assembly language described in the previous section. There are a number of reasons why this reduction is interesting: 1. It may help to understand SuperString dynamics more deeply (later in this chapter).\n122. It will deepen our understanding of computer languages. 3. It provides a basis for th e understanding of Quantum Computers. 4. It may have a role in resear ch on one of the major questions of computer science: provi ng a program actually does what it is designed to do. Algebrai c formalisms are generally easier to prove theorems then English-like formalisms. The algebraic representation can be defined at the level of individual bits based on anti-commuting Fe rmi operators. But it seems more appropriate to develop a representa tion for “words” consisting of some number of bits. An algebraic repr esentation for a word-based assembly language can be developed using commuting harmonic oscillator-like raising and lowering operators. A word consists of a number of b its. In currently popular computers the word size is 32 bits (32-bi t computer). The size of the word determines the largest and smallest integer that can be stored in theword. The largest integer that can be stored in a 32-bit word is 4,294,967,294 and the smallest integer that can be stored in a 32-bit word is 0 if we treat words as holding unsigned integers. To develop a simple algebraic repr esentation of assembly language we will assume the size of a word is so large that it can be viewed as infinite to a good approximation. (I t is also possible to develop algebraic representations for finite word sizes.) As a result memory locations can contain non-negative in tegers of arbitrarily large value. Register Program Counter Address Memory 0 1 2 . . . Figure. Visualization of a Computer with infinite words. To establish the algebraic repres entation we associate a harmonic raising operator a i@ and a lowering operator a i with each memory location. These operators satisfy the commutation relations: [ ai, aj@] = \u0014ij [ ai, aj] = 0 [ ai@, aj@] = 0 where \u0014ij is 1 if i = j and zero otherwise. We define a pair of raising and lowering operators fo r the register r and r@ with commutation relations [ ri, rj@] = \u0014ij [ ri, rj] = 0 [ ri@, rj@] = 0Word - infinite …Word - infinite … $ $ $ CPUWord - infinite … Word - infinite …\n13The ground state of the computer is the state with the values at all memory locations set to zero. It is represented by the vector | 0, 0, 0, … > h | 0 > h \u0005V A state of the computer will be represented by a vector of the form | n, m, p, … > = N (r@)n(a0@)m (a1@)p … | 0 > where N is a normalization constant and with the first number being the value in the regi ster, the second number the value at memory location 0, the third number the valu e at memory location 1, and so on. For simplicity we will not consider superpositions of computer states at this point. We will discuss supe rpositions later in this chapter. Within this limitation we can set a computer state to have certaininitial values in memory and then have it evolve by executing a“program” to a final computer state with a different set of computervalues in memory. The “program” is a mapping of the instructions of an assembly language program to al gebraic expressions in the raising and lowering operators. Basic Operators of the Algebraic Representation The key operators that are required for the algebraic representation are: Fetch the Value at a Memory Location (Number Operator) Nm = a m@am For example, Nm | … , n, … > = n | … , n, … > mth memory location valueSet the Value at Memory Location m to Zero Mm = (am)Nm ªNm! The above expression for M m is symbolic. The expression represents the following expression in which the operators are carefully orderedto avoid complications (c-numbers etc.) resulting from reordering. M m h (ln a m)q Nmq 1 q q! ªNm! where the sum ranges from 0 to ∞. When M m is applied to a state it sets the value of the mth memory location to zero. Mm | … , n, … > = (a m)n | … , n, … > ªn! mth memory location value = | … , 0, … > The repeated applica tion of factors of N m to the state results in factors of n. Change the Value at Memory Location m from 0 to the Value at Location n Pmn = (am@)Nn ªNn! The above expression for P mn is also symbolic. The expression represents the following expressi on in which the operators are\n14carefully ordered to avoid compli cations (c-numbers etc.) resulting from reordering. Pmn h (ln a m@)q Nnq 1 q q! ªNn! where the sum ranges from 0 to ∞. When P mn is applied to a state it changes the value of the mth memory location from zero to the value at the nth memory location. mth nth Pmn | … , 0, … , x, … > = (a m@)x | … , 0, … , x, …> ªx! = | … , x, … , x, … > The application of the factors of N n to the state results in factors of x that lead to the above expression when summed. The operators M m and P mn enable us to simply express the algebraic equivalent of assembly language instructions: LOAD m – load the value at memory location m into the register Prm Mr STORE m – store the value in the re gister at memory location m Pmr Mm SHIFT k – shift the value in the register by k bits. If k is positive the bit shift is to the right and if k is negative the bit shift is to the left. The bits are numbered from the leftmost bit which is bit 0corresponding to 20. The next bit is bit 1 corresponding to 21 and so on. If the bit shift is to the right (k > 0) then we assume the padding bits are 0’s. For example a shift of the bit pattern for 7 = 1110000 … one bit to the right is 14 = 01110000 … As a result the value in the register is doubled (k = 1), quadrupled (k = 2), and so on. The algebraic expression for a k bit right shift is (ln a r@)q Srq ªNr! q q! ªTr! where Sr = (2k – 1)N r and Tr = 2kNr If the bit shift is to the left (negat ive k), then we assume zero bits are added “at ∞”. If k = -1 then the effect of left shift is to divide the value in the register by two (dropping the fr actional part). If k = -2 then the effect of left shift is to divide the value in th e register by four (dropping the fractional part) and so on. The algebraic expression that implements left shift is (ln a r)q Urq ªNr! q q! ªVr! where Ur = N r - [2kNr ] and Vr = [ 2kNr ]\n15with [ z ] being the value of z trunc ated to an integer (fractional part dropped). ADD m – add the value at memory location m to the value in the register (ln a r@)q Nmq ªNr! q q! ª(Nr + N m)! SUBTRACT m – subtract the value at memory location m from the value in the register (assumes the valu e in the register is greater than or equal to the value at location m) (ln a r)q Nmq ªNr! q q! ª(Nr - N m)! MULTIPLY m – multiply the value in the register by the value at memory location m (ln a r@)q (N r )q(Nm - 1)q ªNr! q q! ª(Nr Nm)! DIVIDE m – divide the value in the register by the value at memory location m (ln a r@)q W q ªNr! q q! ªX! whereW = N r - [ N r N m ] and X = [ N r N m ] with [ z ] being the value of z trunc ated to an integer (fractional part dropped). AND m – change the value in the regi ster by “and-ing” it with the value at memory location m ((ln a r@)q(W)q\u0018 (W) + (ln a r)q (-W)q\u0018 (-W) ) ªNr! q q! ªX! where W = N r & N m - N r and where X = N r & N m with \u0018(z) = 1 if z > 0 and 0 if z < 0. The & operator (adopted from the C programming language) performs bitwise AND. Corresponding bits in each operand are “multiplied” together using the multiplicationrules: 1 & 1 = 11 & 0 = 0 & 1 = 0 & 0 = 0 For example the binary numbers 1010 & 1100 = 1000 or in base 10 5 & 3 = 1. OR m – change the value in the regi ster by “or-ing” it with the value at memory location m\n16 (ln a r@)q(W)q ªNr! q q! ªX! where W = N r | N m - N r and where X = N r | N m The | operator (adopte d from the C programming language) performs bitwise OR. Corresponding bits in each operand are “multiplied” together using the multiplication rules: 1 | 1 = 1 | 0 = 0 | 1 = 10 | 0 = 0 For example the binary numbers 1010 | 1100 = 1110 or in base 10 5 | 3 = 7. NOT – change the value in the register by “noting” it ((ln a r@)q(W)q\u0018 (W) + (ln a r)q (-W)q\u0018(-W)) ªNr! q q! ªX! where W = ~N r - N r and where X = ~N r with \u0018(z) = 1 if z > 0 and 0 if z < 0. The ~ operator (adopted from the C programming language) performs bitwise NOT. Each 1 bit isreplaced by a 0 bit and each 0 bit is replaced by a 1 bit. Since we have infinite words in our computer we supplement this rule with the restriction that the ex change of 1’s and 0’s only is made up to and including the rightmost 1 bit in the operand. The 0 bits beyond that remain 0 bits. For example the binary number ~101 = 010 or in base10, ~3 = 2. INPUT m – input a value storing it at memory location m. The input device is usually associated with a memory location from which the input symbolically takes place. We will designate the memory location of the input device as in. P min Mm OUTPUT m – output the value at memory location m. The output device is usually associated with a memory location to which output symbolically takes place. We w ill designate the memory location of the output device as out. Poutm Mout TRA m – set the value of the pr ogram counter to the value at memory location m. If we designate the program counter memorylocation as pc then this instruction is mapped to P pcm Mpc TZR m – set the value of the pr ogram counter to the value at memory location m if the value in the register is zero. (Ppcm Mpc) \u0018(Nr) \u0018(-Nr) using \u0018(0) = 1.\n17HALT – stop execution of the program. The halt in a program is mapped to a “bra” state vector. < … | A Simple Assembly Language Program Assembly language instructions can be combined to form an assembly language program. Perhaps the best way to see how the algebraic representation of assembly language works is to translate a simple assembly language program into its algebraic equivalent. The program that we will consider is:1 INPUT x 2 INPUT y3 LOAD x4 ADD y5S T O R E z6 OUTPUT z7 HALT This program translates to the algebraic equivalent: 7 6 5 4 3 2 1 Steps < … | P outz Mout P zr Mz (ar@)Ny ªNr! P rx Mr P yin My P xin Mx | … > ª(Nr + N y)! where the power of ar@ is represented by a pow er series expansion as seen earlier. The algebraic expression in the br ackets produces one output state from a given initial state. The valu es in memory after the last step correspond to one and only one output state of the form: < n, m, p, … | = (N (r@)n(a0@)m (a1@)p … | 0 >)@where N is a normalization constant. This simple program does not produce a superposition of states. As a result programs of this type are analogous to ordinary programs for normal, non-Quantum computers. The numbers in memory after theprogram concludes are the “output” of the program. We will seeprograms in succeeding sections that take a computer of fixed state N (r @)n(a0@)m (a1@)p … | 0 > and produce a superpos ition of states that must be interpreted quantum mechanica lly. These programs are quantum in nature and the computer that runs them must be a quantum computer. Programs and Program Logic The simple program of the last section corresponded to a sequential program that executed step by ste p. We now turn to more complex programs with program logic that supports non-sequen tial execution of programs. When this type of progr am executes the execution of the instructions can lead to jumps from one instruction to another instruction in another part of the program. Programs are linear – one instruction executes after another. But they are not sequential – the instructions do not always execute step by step sequentially. A program can specify ju mps (“goto” instructions) in the code from the current instruction to an instruction se veral steps after the current instruction or several st eps back to a previous instruction. The code then executes sequentially until the next jump isencountered. These jumps in the code at the le vel of assembly language implement the control constructs such as go to statements, if expressions, for loops, and switch expressions seen in higher level languages such as C and C++. Jumps in code can be implemented in the algebraic representation of programs by having a program counter memory value that incrementsas the algebraic factor correspondi ng to each step executes. Steps in\n18the program can execute or not ex ecute depending on the current value of the program counter. Changes in the program counter value are made using the TRA and TZR instructions. In the algebrai c representation the program counter variable can be used to manage the execution of the program steps. The key algebraic constructs supporting non-seque ntial program execution are: Execute instruction only if PC [ n ( … ) \u0018 ( n - N pc) Execute instruction only if PC m n ( … ) \u0018 ( Npc - n) Execute instruction only if PC = n ( … ) \u0018\u0018 ( Npc – n) Execute instruction only if PC not equal to n ( … ) \u0018( Npc – n) + \u0018( n - N pc) - 2\u0018\u0018( Npc – n) where the parentheses contain one or more instructions and where \u0018\u0018(x) = 1 if x = 0 and zero otherwise . The function \u0018\u0018(x) can be represented by step functions as \u0018\u0018(x) = \u0018(x) \u0018(-x) Using these constructs we can c onstruct non-sequential programs that supprt “goto’s”, if’s and other contro l constructs seen in higher level languages.To illustrate this feature of the algebraic representation we will consider an enhancement of th e assembly language program seen earlier:1 INPUT x2 INPUT y3 LOAD x4 TZR y5 ADD y6S T O R E z7 OUTPUT z8 HALT This program has the new feature th at if the first input – to memory location x – is zero, then instruct ion 4 will cause a jump to the instruction specified by the value stored at memory location y. For example if the inputs are 0 pl aced at memory location x and 2 placed at memory location y, then the TZR instruction will cause the program to jump to instruction 2 from instruction 4. Then the program will proceed to execute from instruction 2. Another example of a case with a jump is if the input to memory location x is zero and the input to memory location y is 6 then the program jumps from instruction 4 to instruction 6 and the program completes execution from there. If the input to memory location x is non-zero no jump takes place. To establish the algebraic equiva lent of the preceding example we have to use the non-sequential cons tructs provided earlier in this section. In addition we must define the equivalent recursively because of the possibility that the program may jump backwards to an earlier instruction in the progr am. If only “forward” jumps were allowed then recursion would not be needed. An algebraic representation of the program that supports only forward leaps is:\n198 7 < … | ( apc@Poutz Mout) \u0018\u0018(Npc- 7) 6 (apc@Pzr Mz) \u0018\u0018(Npc- 6) 5 ( apc@ (ar@)Ny ªNr! )\u0018\u0018(Npc- 5) ª(Nr + N y)! 4 (apc@)1-\u0018\u0018 (Nr) (Ppcy Mpc)\u0018\u0018(Nr) \u0018\u0018(Npc- 4) 3 apc@PrxMr 2 apc@Pyin My 1 apc@Pxin Mx apc@Mpc | … > The program steps are numbere d above each corresponding expression. The step function expres sions enable the jump to take place successfully. A program with forward and back ward jumps supported requires a recursive definition. We will define the recursive function f() with: 7 f() = (apc@Poutz Mout) \u0018\u0018(Npc- 7) 6 (apc@Pzr Mz) \u0018\u0018(Npc- 6) 5 (apc@ (ar@)Ny ªNr! ) \u0018\u0018(Npc- 5) ª(Nr + N y)! 4 (apc@)1-\u0018\u0018(Nr) (f()P pcy Mpc)\u0018\u0018(Nr) \u0018\u0018(Npc- 4) 3 ( apc@PrxMr ) \u0018\u0018(Npc- 3) 2 ( apc@Pyin My) \u0018\u0018(Npc- 2) 1 ( apc@Pxin Mx) \u0018\u0018(Npc- 1) The program is f()a pc@Mpc | … > This program is well behaved except if the input value placed at the y memory location is 4. In this case the program recursively executes forever. This defect can be removed by using another memory locationfor a counter variable. We can modify the program so that the program only recursively calls itself a finite number of times by having each recursive call decrease the counter variable by one. When th e value reaches zero the recursion terminates. An example of such a program (set to allow at most 10 iterations of the recursion) is:\n20 7 g() = (apc@Poutz Mout) \u0018\u0018(Npc- 7) 6 (apc@Pzr Mz) \u0018\u0018(Npc- 6) 5 (apc@ (ar@)Ny ªNr! ) \u0018\u0018(Npc- 5) ª(Nr + N y)! 4 (apc@)1-\u0018\u0018(Nr) ((a pc@)1-\u0018(Nw)(g())\u0018(Nw)awPpcy Mpc)\u0018\u0018(Nr) \u0018\u0018(Npc- 4) 3 ( apc@PrxMr ) \u0018\u0018(Npc- 3) 2 ( apc@Pyin My) \u0018\u0018(Npc- 2) 1 ( apc@Pxin Mx) \u0018\u0018(Npc- 1) The program is g()a pc@Mpc (aw@)10Mw | … > where w is some memory location. We conjecture that any assembly language program using the previous ly specified instructions can be mapped to an algebraic represen tation – possibly with the use of additional memory for variables su ch as the counter variable seen above.Using the algebraic constructs supporting non-sequential program execution we can create algebrai c representations of assembly language programs. These programs ha ve a definite input state and through the execution of the program th ey evolve into a definite output state -–not a superposition of output states. Therefore they faithfully represent assembly language progra ms. On the other hand they are quantum in the sense that they use states and harmonic oscillator-like raising and lowering operators. The types of programs we are creating in this approach are “sharp” on th e space of states. One input state evolves through the program’s execu tion to one and only one output state with probability one. These types of programs are analogous to free field theory in which incoming particles evolve without interaction to an output state containing the same particles. In the next section we extend the ideas in this section to quantum programming where a variety of output states are possible – each with a certain probability of being produced. Quantum Assembly Language™ Programs In this section we will first look at a simplified quantum program that illustrates quantum effects but in act uality is a sum of deterministic assembly language programs ma pped to algebraic equivalents. Consider a “quantum” program that is the sum of three ordinary programs g 1(), g 2() and g 3() of the type seen in the last section. Further let us assume the set of orthonormal states | n, m, p, … > that we saw in the previous sections with < X | Y > = \u0014XY where \u0014XY represents a product of Kronecker \u0014 functions in the individual values in memory of the | X > and | Y > states. Further let us assume\n21| n1, m 1, p1, … > = g 1()| … > | n2, m 2, p2, … > = g 2()| … > | n3, m 3, p3, … > = g 3()| … > for some initial state of the quantum computer. Then \u0011g1() + \u0012g2() + \u0013g3()| … > is a “quantum” program where \u0011, \u0012, and \u0013 are constants such that |\u0011|2 + |\u0012|2 + |\u0013|2 = 1 The quantum program produces the state | n 1, m 1, p 1, … > with probability | \u0011|2, the state | n 2, m 2, p2, … > with probability | \u0012|2, and the state | n 3, m 3, p3, … > with probability | \u0013|2. We now have a quantum probabilis tic computer. The programs g 1(), g2() and g 3() are being executed in parallel in a quantum probabilistic manner. Currently, the most feasible wa y of creating a Quantum Computer with current technology or reasona ble extrapolations of current technology is to create a material which approximates a lattice with spins at each lattice site that we can orient electromagnetically at the beginning of a program. The execu tion of a program takes place by applying electromagnetic fields that have a time dependence specific to the computation. The electroma gnetic fields implement a custom- tailored set of interactions between the spins in the material thatsimulates the calculation to be performed. The interactions are specified with some Hamiltonian or some effective Hamiltonian and the initia l state of the la ttice spins evolves dynamically to some configuration that is then measured.The Hamiltonians are normally sp ecified using the space-time formalism that is a familiar part of Quantum Mechanics. AHamiltonian specifies the time evolu tion of a system starting from an initial state. We can introduce an explicit time dependence in states by using the notation: | \u000f(t) > to denote the state of a Quantum Com puter at time t. The general state of the computer at time t can be written as a superposition of the number representation states: | \u000f(t) > = f n(t)| n 1, n2, n3, … > n where n represents a set of values n 1, n2, n3, … The time evolution of the states can be specified using the Hamiltonian operator H as | \u000f(t) > = e-iHt| \u000f(0) > With this Hamiltonian formulation we can imagine wishing to simulate a physical (or mathematical) process, defining a Hamiltonianthat corresponds to the process, and then creating an experimental setup using a set of lattice spins in some material that implements the simulation. The experimental setup will prepare the initial state of the spins, create a fine tuned interacti on that simulates the physics of the process, and then, after the system has evolved, will measure the stateof the system at time t. Repeated performance of this procedure will determine the probability distribution associated with the final state of the Quantum Computer. The probabil ity distribution is specified by |f n(t)|2 as a function of the sets of numbers denoted by n. A simple example of a Hamiltonian that causes a Quantum Computer to evolve in a non-trivial way is:\n22 ∞ H = am+1@ am m = 0 (This example was chosen partly b ecause it has a form similar to a Virasoro algebra generator in SuperS tring Theory.) Let us assume the initial state of the Quantum Computer at t = 0 is | 1, 0, 0, 0, … > that is, an initial value of 1 in th e first word in memory and zeroes in all other memory locations. At time t the state of memory is: nth memory location ∞ | \u000f(t) > = fn(t)| 0, 0, … , 1, 0, … > n = 0 with fn(t) = (-it)n/n! using the power series expansi on of the exponentiated Hamiltonian expression. The probability of finding the state nth memory location | 0, 0, … , 1, 0, … > is (tn/n!)2 At first glance the Hamiltonian approach is very different from the Quantum Assembly Language™ appr oach discussed above. However these approaches can be interre lated in special cases and (we conjecture) in the general case through sufficiently clevertransformations. For example, the preceding Hamiltonian can be re- expressed as assembly language instructions ∞ H = (STORE (m+1))(ADD “1”)(LOAD (m+1)) $ m = 0 $ (STORE m) (SUBTRACT “1”)(LOAD m) where a value is loaded into the re gister from memory location m and then 1 is added to the value in the register. The “1” expression represents a literal va lue one not a memory location. The parentheses around m+1 indicates it is the (m+1)th memory location – not the addition of one to the value at the mth location. The preceding assembly language expression for H can be replaced with the algebraic representation expression: ∞ H = Pm+1r Mm+1 ar@ 1 P rm+1MrPmrMmarªNrPrmMr m = 0 ª(Nr + 1) This complex expression is not an improvement in one sense. The original Hamiltonian expression was much simpler. Its importance isthe mapping that it embodies from a quantum mechanical Hamiltonian to an assembly language expression to an algebraic representation of the assembly language. If we regard the value in the re gister as a “scratchpad” value as programmers often do, then we can establish a representation of a m@ and am in terms of the algebraic representation of assembly language instructions. am@ h Pmr Mm ar@ 1 P rm Mr ª(Nr + 1) and\n23am h Pmr Mm ar ªNr Prm Mr The power series expansion of the exponentiated Hamiltonian in the previous example is an example of the use of Perturbation Theory. The direct solution of a problem is of ten not feasible because of the complexity of the dynamics. Physicists have a very well developedtheory for the approximate solution of these difficult problems calledPerturbation Theory. Perturbation Theo ry takes an exact solution of a simplified version of the problem a nd then calculates corrections to that solution that approximate the ex act solution of th e problem. In the preceding example the initial st ate of the Quantum Computer represents a time-independent desc ription of the Quantum Computer. The time-dependent description of the Quantum Computer which isthe sought-for solution requires the evaluation of the result of the application of the exponentiated Hamilt onian to the initial state. For a small elapsed time, the exponential can be expanded in a power series and the application of the first few terms of the power series to the initial state approximates the actual state of the Quantum Computer. Thus we have a Perturbation Theory for the time evolution of theQuantum Computer expressed as an expansion in powers of the elapsed time. Bit-Level Quantum Computer Language In the previous section we examined a Quantum Assembly Language™ with words consisting of an infinite sets of bits. In this section we will examine the opposit e extreme – a Quantum Computer Language with one-bit words. One can also create Quantum ComputerLanguages for intermediate cases such as 32-bit words. A Bit-Level Quantum Computer Language can be represented with anti-commuting Fermi operators b i and b i@ for i = 0, 1, 2, … representing each bit location in the Quantum Computer’s memorywith the anti-commutation rules: { b i, bj@} = \u0014ij{ bi, bj} = 0 { bi@, bj@} = 0 where \u0014ij is 1 if i = j and zero ot herwise. We will assume an (unrealistic) one-bit register with a pair of raising and lowering operators r and r@ for the register with the anti-commutation relations: { ri, rj@} = \u0014ij { ri, rj} = 0 { ri@, rj@} = 0 The ground state of the computer is th e state with the va lues at all bit memory locations set to zero. It is represented by the vector | 0, 0, 0, … > h | 0 > h \u0005V A typical state of the computer will be represented with a vector such as | 1, 1, 1, … > = r@b0@ b1@ … | 0 > with the first number being the va lue in the register, the second number the value at memory locat ion 0, the third number the value at memory location 1, and so on. A specified Quantum Computer state evolves as a Quantum Computer Program executes to a final comput er state. A Bit-Level Quantum Computer Program can be represen ted as an algebraic expression in anti-commuting raising and lowe ring operators. The approach is similar to the approach seen earlie r in this chapter for infinite-bit words using commuting operators.\n24Basic Operators of the Bit-Level Quantum Language The key operators that are required for the algebraic representation of a Bit-Level Quantum Computer Language™ are: Fetch the Value at a Memory Location (Number Operator) Nm = b m@bm For example, Nm | … , 1, … > = | … , 1, … > mth memory location value Set the Value at Memory Location m to Zero Mm = (b m)Nm The above expression for M m is symbolic. The expression represents the following expression in which the operators are carefully orderedto avoid complications (c-numbers etc.) resulting from reordering. M m h eNm ln b m = (ln b m)q Nmq q q! where the sum ranges from 0 to ∞. M m becomes Mm = 1 + (b m – 1)N m using the identity N m = N m2. When M m is applied to a state it sets the value of the mth memory location to zero.Mm | … , x, … > = | … , 0, … > mth memory location value Change the Value at Memory Location m from 0 to the Value at Location n Pmn = (b m@)Nn The above expression for P mn is also symbolic. The expression represents the following expressi on in which the operators are carefully ordered to avoid compli cations (c-numbers etc.) resulting from reordering. Pmn h (ln b m@)q Nnq q q! where the sum over q ranges from 0 to ∞. Using the identity N m = N m2 the expression for P mn simplifies to: Pmn = 1 + (b m –1)N m When P mn is applied to a state it changes the value of the mth memory location from zero to the value at the nth memory location. mth nth Pmn | … , 0, … , x, … > = (b m@)x | … , 0, … , x, …> = | … , x, … , x, … > We can use the operators M m and P mn to express bit-wise assembly language instructions:\n25LOAD m – load the value at memory location m into the register Prm Mr = (1 - N r + b r)(1 - N m) + (N r + b r@)Nm The first term on the right handles the case N m = 0 and the second term on the right handles the case N m = 1. STORE m – store the value in the register at memory location m Pmr Mm = (1 - N m + b m)(1 - N r) + (N m + b m@)Nr The first term on the right handles the case N r = 0 and the second term on the right handles the case N r = 1. ADD m – add the value at memory location m to the value in the register (br@)Nm = (ln b r@)q Nmq q q! = 1 + (b r@ – 1)N m If both the register and memory b it m have values of one then the application of this ope rator expression to th e quantum state produces zero. SUBTRACT m – subtract the value at memory location m from the value in the register (br)Nm = (ln b r)q Nmq q q!= 1 + (b r – 1)N m If the value in the register is zero and the value at location m is one the application of this operator produces zero. MULTIPLY m – multiply the value in the register by the value at memory location m (br@)(Nm -1)Nr = (ln b r@)q (N r )q(Nm - 1)q q q! = 1 + (b r – N r)(1 - N m) Other assembly language instructions can be expressed in algebraic form as well. The operator algebra that we have developed for a bit-wise Quantum Assembly Language™ or a Quantu m Machine Language™ provides a framework for the investigation of the properties of Quantum Languages within an algebraic framew ork – a far simpler task than the standard quantum linguistic approaches. Quantum High Level Computer Language Programs The Quantum Assembly Language™ representation that we have developed earlier in this chapter forms a basis for high level Quantum Programming Languages. These langua ges are analogous to high level computer languages such as C or C++ or FORTRAN. In ordinary computation a statemen t in a high level language such as a = b + c;\n26in C programming is mapped to a set of assembly language by a C compiler. A simple mapping of th e above C statement to assembly language would be LOAD ab ADD acSTORE aa where aa is the memory address of a, ab is the memory address of b and ac is the memory address of c. If we decide to define a High Level Quantum Computer Language™ then it would be natural to define it analogously in terms of a Quantum Assembly Language™. A statemen t in the High Level Quantum Computer Language™ would map to a set of Quantum Assembly Language™ instructions. For example, a = b + c would map to the algebraic expression P aar Maa (ar@)Nac ªNr! P rab Mr ª(Nr + N ac)! using the formalism developed earlie r in this chapter to LOAD, ADD and STORE. The definition of high level Quan tum Computer Languages™ in this approach is straightforward. One can then imagine creating programs in these languages for execution on Quantum Computers just as ordinary programs are created for ordinary computers. Another approach to higher leve l Quantum Computer Languages™ is to simply express them directly us ing raising and lowering operators – not in terms of Quantum Assembly Language™ instructions. Forexample the preceding a = b + c; stat ement can be directly expressed as(a aa@)Nac+Nab (aaa)Naa 1 ª(Nac + N ab)! ªNaa! Simple High Level Quantum Comput er programs can be expressed as products of algebraic expressions embodying the statements of the program. These programs are sharp on the set of memory states takingan initial memory state that is an eigenstate of the set of number operators N m into an output eigenstate of the number operators. A general High Level Quantum Comput er Program is a sum of simple High Level Programs. For example, \u0011h1() + \u0012h2() + \u0013h3()| … > where \u0011, \u0012, and \u0013 are constants such that |\u0011|2 + |\u0012|2 + |\u0013|2 = 1 The sum of simple programs \u0011h1() + \u0012h2() + \u0013h3() produces the state | n1, m 1, p1, … > with probability | \u0011|2, the state | n 2, m 2, p2, … > with probability | \u0012|2, and the state | n 3, m 3, p3, … > with probability | \u0013|2. An initial eigenstate of the numbe r operators is tranformed into an output state that is a superpositi on of number operator eigenstates. In this case we use probabilities to specify the likelihood that a given output eigenstate will be found when the output state is measured. A Hamiltonian can also be used to specify the time evolution of a system starting from an initial state. Using the notation: | \u000f(t) > to denote the state of a Quantum Com puter at time t the general state of a computer at time t can be wri tten as a superposition of number representation states: | \u000f(t) > = fn(t)| n 1, n2, n3, … > n\n27where n represents a set of values n 1, n2, n3, … The time evolution of the states can be specified using the Hamiltonian operator H as | \u000f(t) > = e-iHt| \u000f(0) > A simple example of a Hamiltonian that causes a Quantum Computer to evolve in a non-trivial way is: ∞ H = (am+2@)Nm+1+Nm (am+2)Nm+2 1 m = 0 ª(Nm+1+N m)! ªNm+2! This Hamiltonian is based on the a = b + c statement above. This Hamiltonian generates a complex s uperposition of states as time evolves. More complex Hamiltoni ans equivalent to programs with several statements can be easily constructed. Quantum C Language™ One of the most important comput er languages is the C programming language developed at Bell Laboratories in the 1970’s. The original version of version of the C language was a remarkable combination of low level (assembly language-like) features and high level features like the mathematical parts of FORTRAN. The variables in thelanguage were integers stored in wo rds just as we saw in the earlier examples in this chapter. (There were several other types of integers aswell – a complication that we will ignore.) Using the ideas seen in the earlier sections of this chapter it is easy to develop algebraic equivalents for mo st of the constructs of the C language and thus create a Quantum C Language™. An importantelement that must be added to the previous development is tointroduce the equivalent of pointers. Simply put pointers are variables that have the addresses of memory locations as their values. The C language has two important operato rs for pointer manipulations:Operator Role Example & Fetch an address ptr = &x; * Fetch/set the value at an address z = *ptr; *ptr = 99; The & operator of C fetches the addr ess of a variable in memory. The example shows a pointer variable pt r being set equal to the address of the x variable. The * (dereferencing) operator can fetch the value at a memory location. The first * exam ple illustrates this aspect: the variable z is set equal to the value at the memory location specified bythe pointer variable ptr. The * opera tor can also be used to set the value at a memory location as illu strated by the second * example. In this example the value 99 is placed at the memory location (address) specified by the ptr pointer variable. These operators can be implemented in the algebraic representation of the Quantum C Language™ in the following way: &w [A, ] where A = m(a m - am@) with the sum from 0 to ∞. If we apply the operator to a raising or lowering operator we obtain its address & am@= [A, am@] = m = & am= [A, am] The equivalent of the * operator is actually a pair of operator expressions. To fetch the value at a memory location we use *m h Nm To set the value to X at a memory location m we use a more complex C language representation: *m = X;\n28An equivalent alge braic expression is: *m(X) h (am@)X (am)Nm 1 ªX! ªNm! *m(X) is a functional notation. So a = b + c can be rewritten as a “pointer” algebraic expression as: (a aa@)*ac + *ab (aaa)*aa 1 ª(*ac + *ab)! ª*aa! Or more compactly using the functional notation as *aa(*ab + *ac) The Quantum C Language™ could be used to define Hamiltonians for a Quantum Computer. Other languages such as Java™, C++, lisp and so on also have Quantum analogues wh ich may be defined in a similar way.\n",
  "metadata": {
    "paper_id": "quant-ph/0201082v1",
    "downloaded_at": "2025-08-29T07:27:10.442555+00:00"
  },
  "processed_at": "2025-08-29T07:27:10.442569+00:00"
}